## FPU.ADD && FPU.SUB

##### 判断

处理边界、NaN

非边界和NaN

操作数无穷大（阶码11111111）

##### 规格化和非规格化

阶码全为0 规格化将阶码变为1

阶码不为0 规格化计算阶码

##### 对阶

右规尾数

##### 借用ALU

尾数做拓展5位0

+ pos + neg   尾数相减 根据第一次相减的tmp结果 
+ neg + pos   尾数相减
+ neg + neg   符号为1 尾数相加 尾数首位为1产生了进位 判断阶码溢出 未产生溢出则截取后 溢出则右移尾数，截取5位以后
+ pos + pos

##### 判断左规

循环 如果阶码<= -126  阶码为0 尾数右移一位

出循环 如果阶码！= -126 或者阶码不全为0 并且尾数全为0   阶码 = -127 

##### 舍入





## FPU.MUL && FPU.DIV

#### 处理边界情况

除法运算中，还需要额外判断除数为0且被除数不为0的情况。

#### 提取符号、阶码、尾数

符号位、指数部分与尾数部分分别为1、8、23位，同时使用3位保护位(GRS保护位)

这一步有三个需要特殊处理的地方：

1. 当有一个操作数提取出的阶码为全1时，应该返回正无穷或负无穷，注意符号需要额外判断。（为什么？考虑无穷乘其他数的结果）
2. 当提取出的阶码为全0时，说明该操作数是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错。（为什么？可以考察IEEE754浮点数标准中阶码为0和阶码为1分别表示2的多少次方）
3. 在这一步中不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。

#### 模拟运算得到中间结果

符号位即为普通乘除得出结果

对于阶码的计算，与加减法运算不同的是，乘除法运算不再需要对阶操作，而是直接计算结果阶码。其计算过程分别为

- 乘法：尾数相乘，阶码相加后减去偏置常数127
- 除法：尾数相除，阶码相减后加上偏置常数

对于27位乘法运算，返回的结果是54位的乘积。由于两个操作数的隐藏位均为1位，所以乘积的隐藏位为2位

为了方便后续操作，需要通过阶码加1的方式来间接实现小数点的左移，修正这个误差，以保证尾数的隐藏位均为1位。

比于加减法运算，乘除法的运算结果破坏规格化的情况更多，增加了阶码为负数的情况。简单分类如下：

1. 运算后54位尾数的隐藏位为0且阶码大于0，此时应该不断将尾数左移并将阶码减少，直至尾数隐藏位恢复为1或阶码已经减为0。
2. 运算后阶码小于0且54位尾数的前27位不全为0，此时应该不断将尾数右移并将阶码增加，直至阶码增加至0或尾数的前27位已经移动至全0。
3. 经过上述两步操作后，尾数基本恢复规格化，但阶码仍有可能破坏规格化，分为以下三种情况：
   - 阶码为"11111111"，发生阶码上溢，此时应该根据符号位判断返回哪一种INF
   - 阶码为0，则说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范。（为什么？可以考察阶码为0000 0001，尾数为0.1000 0000 0000 0000 0000 0000 00的浮点数的规格化过程）
   - 阶码仍小于0，发生阶码下溢，此时又应该返回什么？

```java
while (隐藏位 == 0 && 阶码 > 0) {
    尾数左移，阶码减1; // 左规
}
while (尾数前27位不全为0 && 阶码 < 0) {
    尾数右移，阶码加1; // 右规
}

if (阶码上溢) {
    将结果置为无穷;
} else if (阶码下溢) {
    将结果置为0;
} else if(阶码 == 0) {
	尾数右移一次化为非规格化数;
} else {
    此时阶码正常，无需任何操作;
}
```